/// <reference types="node" />
/** @internalapi */
/** This second comment is required for typedoc to recognise the WHOLE FILE as @internalapi */
import { OAuth } from 'oauth';
import { IHttpClient } from './BaseAPIClient';
import * as fs from 'fs';
import * as http from 'http';
import { AttachmentsResponse } from '../AccountingAPI-types';
export interface IToken {
    oauth_token: string;
    oauth_token_secret: string;
}
export interface IOAuth1State extends IToken {
    oauth_session_handle?: string;
    oauth_expires_at?: Date;
}
export interface IOAuth1Configuration {
    consumerKey: string;
    consumerSecret: string;
    tenantType: string;
    apiBaseUrl: string;
    apiBasePath: string;
    oauthRequestTokenPath: string;
    oauthAccessTokenPath: string;
    signatureMethod: string;
    accept: string;
    userAgent: string;
    callbackUrl: string;
}
export interface IOAuth1Client {
    agent?: http.Agent;
    getRequestToken(): Promise<IToken>;
    buildAuthoriseUrl(requestToken: IToken): string;
    swapRequestTokenforAccessToken(requestToken: IToken, oauth_verifier: string): Promise<IOAuth1State>;
    refreshAccessToken(): Promise<IOAuth1State>;
}
export interface IOAuth1HttpClient extends IHttpClient, IOAuth1Client {
}
export declare class OAuth1HttpClient implements IOAuth1HttpClient {
    private config;
    private oAuthLibFactory;
    private _state;
    private oauthLib;
    agent: http.Agent;
    private _defaultHeaders;
    private resetToDefaultHeaders();
    constructor(config: IOAuth1Configuration, authState?: IOAuth1State, oAuthLibFactory?: (config: IOAuth1Configuration) => typeof OAuth);
    getRequestToken: () => Promise<IToken>;
    buildAuthoriseUrl: (requestToken: IToken) => string;
    swapRequestTokenforAccessToken: (requestToken: IToken, oauth_verifier: string) => Promise<IOAuth1State>;
    refreshAccessToken: () => Promise<IOAuth1State>;
    writeUTF8ResponseToStream: (endpoint: string, mimeType: string, writeStream: fs.WriteStream) => Promise<void>;
    writeBinaryResponseToStream: (endpoint: string, mimeType: string, writeStream: fs.WriteStream) => Promise<void>;
    private _OURperformSecureRequest;
    readStreamToRequest: (endpoint: string, mimeType: string, size: number, readStream: fs.ReadStream) => Promise<AttachmentsResponse>;
    get: <T>(endpoint: string, customHeaders?: {
        [key: string]: string;
    }) => Promise<T>;
    put: <T>(endpoint: string, body: object, customHeaders?: {
        [key: string]: string;
    }) => Promise<T>;
    post: <T>(endpoint: string, body: object, customHeaders?: {
        [key: string]: string;
    }) => Promise<T>;
    delete: <T>(endpoint: string, customHeaders?: {
        [key: string]: string;
    }) => Promise<T>;
    private setState(newState);
    private assertAccessTokenIsSet();
    private _createHttpClientWithProxySupport(port, hostname, method, path, headers, sslEnabled?);
}
